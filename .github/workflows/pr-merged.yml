name: '[autorelease] On PR merged'

on:
  pull_request:
    branches:
    - main
    types: [closed]
  workflow_dispatch:    # Allow running the workflow manually from the GitHub UI
    inputs:
      fake-version:
        description: 'Fake version number'

jobs:
  init:
    runs-on: ubuntu-latest
    # Check this event is a merge of an autorelease PR
    if: github.event.pull_request.merged == true && contains(github.event.pull_request.labels.*.name, 'autorelease') || github.event_name == 'workflow_dispatch'
    outputs:
      build-version: ${{ inputs.fake-version || steps.get-release-info.outputs.version }}
      is-prerelease: '${{ steps.semver_parser.outputs.prerelease && true || false }}'
      release-notes: '${{ steps.get-release-info.outputs.release-notes }}'
    steps:
    - uses: actions/checkout@v4

    - name: Get latest release info
      id: get-release-info
      uses: release-flow/keep-a-changelog-action/@v3
      with:
        command: query
        version: latest

    - name: Display release notes
      run: |
        echo "${{ steps.get-release-info.outputs.release-notes }}"

    - name: Parse current version number
      uses: madhead/semver-utils@v4
      id: semver_parser
      with:
        # The PR we are merging should have updated the changelog to set the target release version as the
        # latest version (this happens in prepare-release.yml)
        version: ${{ steps.get-release-info.outputs.version }}

  build:
    if: (github.event.pull_request.merged == true && contains(github.event.pull_request.labels.*.name, 'autorelease')) || github.event_name == 'workflow_dispatch'
    needs: init
    uses: ./.github/workflows/build-and-test.yml
    with:
      build-version: ${{ needs.init.outputs.build-version }}

  create_release:
    needs: 
    - init
    - build
    runs-on: ubuntu-latest
    # Check this event is a merge of an autorelease PR
    if: github.event.pull_request.merged == true && contains(github.event.pull_request.labels.*.name, 'autorelease') || github.event_name == 'workflow_dispatch'
    env:
      ARTIFACT_PATH: ${{ github.workspace }}/artifacts
    steps:

    # We need to create a token
    # a) To have the GH release appear to be generated by our app instead of github-actions (cosmetic)
    # b) So we can use the same mechanism to get a token when running locally under act
    - uses: tibdex/github-app-token@v2
      id: generate-token
      with:
        app_id: ${{ secrets.RELEASEBOT_APP_ID }}
        private_key: ${{ secrets.RELEASEBOT_PRIVATE_KEY }}
        github_api_url: ${{ github.api_url && github.api_url || 'https://api.github.com' }}

    - name: Download nupkg artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ needs.build.outputs.nupkg-artifact }}
        path: ${{ env.ARTIFACT_PATH }}

    - name: Create Draft Release
      id: create_draft_release
      uses: richtea/.github/actions/release/create@v1
      with:
        github-token: ${{ steps.generate-token.outputs.token }}
        tag-name: 'v${{ needs.init.outputs.build-version }}'
        release-name: 'Release ${{ needs.init.outputs.build-version }}'
        draft: true
        prerelease: ${{ needs.init.outputs.is-prerelease }}
        body: ${{ needs.init.outputs.release-notes }}

    - name: Upload Release Assets
      id: upload_release_assets
      uses: richtea/.github/actions/release/upload-asset@v1
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        upload-url: '${{ steps.create_draft_release.outputs.upload-url }}'
        files: '${{ env.ARTIFACT_PATH }}/*'
  
    - name: Display instructions
      run: |
        echo "::notice title=Draft Release Prepared::A draft release has been prepared for you to approve: ${{ steps.create_draft_release.outputs.html-url }}"
  